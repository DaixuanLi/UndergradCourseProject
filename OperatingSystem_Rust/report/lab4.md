## Lab4 实验报告

2017012289 李岱轩 计72

### 1 `process::init`的执行过程

* 创建一个空的线程boot_thread作为当前线程；
* 创建一个内核态线程temp_thread，具体来说，首先先为这个线程开好内核栈；之后建立这个线程的上下文（ContextContent），上下文包括返回值ra，satp的值，寄存器s0-s12的值和一个把栈顶设置为新线程的栈顶，把各个权限寄存器正确设置的中断帧；最后将这个中断帧放在这个线程的栈顶；
* 使用append_initial_argument函数，将进入temp_thread函数所需要的参数（temp_thread的地址，boot_thread的地址，最后一个参数没有用，设置成了0）；
* 使用switch_to函数，切换线程，即将现场设置为temp_thread的现场，具体来说，保存所有当前线程寄存器，切换到新的线程栈顶，恢复页表寄存器，刷新TLB，恢复ra，s0-s11寄存器（**这里被后面覆盖了，其实没用**），回收这些寄存器所在的栈空间，使用ret跳转到__trapret；
* 在__trapret中，将返回地址设置为entry（这里是temp_thread程序），将temp_thread函数的参数设置好，跳转到temp_thread；
* 在temp_thread中输出字符串，之后再次使用switch_to函数,因为之前已经保存过boot_thread的现场，此处直接恢复，之后通过ret从switch_to函数中跳出；
* 输出字符串，进入死循环。

**PS.** 感觉用__trapret并不好看，而且切换线程的时候，直接切换到函数开头有些特殊。感觉这个逻辑还可以优化。需要解决的主要问题我能想到的有：权限应该如何设置，中断要怎么办等。

### 2 `switch`时特殊寄存器和栈的使用情况

所有寄存器使用情况如下表：

| 寄存器         | 使用情况                                                     |
| -------------- | ------------------------------------------------------------ |
| ra,s0 - s11,sp | 原来线程的寄存器值被保存到栈上，新的线程的寄存器值被还原回来 |
| a0 - a2        | 设置成了temp_thread的输入参数**（仅第一次切换）**            |
| 其他通用寄存器 | 没有变化                                                     |
| satp           | 原来线程的寄存器值被保存到栈上，新的线程的寄存器值被还原回来 |
| sscratch       | 0 sp已经是新栈地址，不用设置**（仅第一次切换）**             |
| sstatus        | SIE false,SPIE true 使能异步中断<br>SPP 设置为Supervisor Mode 因为是内核线程**（仅第一次切换）** |
| sepc           | 设置成为temp_thread函数的地址**（仅第一次切换）**            |

栈的使用情况如下：

boot_thread栈，从上到下是地址从底到高，切换后就被保存了以下的内容：

| 栈内容       |
| ------------ |
| ra           |
| satp         |
| 依次是s0-s11 |

切换回来之后，这些内存被回收。

temp_thread栈

一开始被保存了所有ContextContent的内容

| 栈内容                                                       |
| ------------------------------------------------------------ |
| ra                                                           |
| satp                                                         |
| 依次是s0-s11                                                 |
| TrapFrame的内容，包含了所有寄存器，其中a0-a2；sscratch,sstatus,sepc的设置如上一题所述 |

进程切换后，前三个内容被回收：

| 栈内容                                                       |
| ------------------------------------------------------------ |
| TrapFrame的内容，包含了所有寄存器，其中a0-a2；sscratch,sstatus,sepc的设置如上一题所述 |

最后sret 我们发现栈内容并没有被回收，我认为这里应该添加栈回收的相关代码，可能是因为这里是部分代码就没有回收。

